<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>README.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>
    <div class="banner">
        
        <h1>
            README.md
        </h1>
        <ul class="files">
            <li>vendor/bundle/ruby/2.6.0/gems/rspec-mocks-3.8.0/README.md</li>
            <li>Last modified: 2019-02-22 15:37:57 +0000</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-RSpec+Mocks+rdoc-image-3Ahttps-3A-2F-2Fsecure.travis-ci.org-2Frspec-2Frspec-mocks.svg-3Fbranch-3Dmaster+rdoc-image-3Ahttps-3A-2F-2Fcodeclimate.com-2Fgithub-2Frspec-2Frspec-mocks.svg"><a href="../../../../../../../classes/RSpec.html"><code>RSpec</code></a> Mocks <a href="http://travis-ci.org/rspec/rspec-mocks"><img src="https://secure.travis-ci.org/rspec/rspec-mocks.svg?branch=master"></a> <a href="https://codeclimate.com/github/rspec/rspec-mocks"><img src="https://codeclimate.com/github/rspec/rspec-mocks.svg"></a></h1>

<p>rspec-mocks is a test-double framework for rspec with support for method stubs, fakes, and message expectations on generated test-doubles and real objects alike.</p>

<h2 id="label-Install">Install</h2>

<pre><code>gem install rspec       # for rspec-core, rspec-expectations, rspec-mocks
gem install rspec-mocks # for rspec-mocks only
</code></pre>

<p>Want to run against the <code>master</code> branch? You&#39;ll need to include the dependent <a href="../../../../../../../classes/RSpec.html"><code>RSpec</code></a> repos as well. Add the following to your <code>Gemfile</code>:</p>

<pre><code>%w[rspec-core rspec-expectations rspec-mocks rspec-support].each do |lib|
  gem lib, :git =&gt; &quot;https://github.com/rspec/#{lib}.git&quot;, :branch =&gt; &#39;master&#39;
end
</code></pre>

<h2 id="label-Contributing"><a href="../diff-lcs-1_3/Contributing_md.html">Contributing</a></h2>

<p>Once you&#39;ve set up the environment, you&#39;ll need to cd into the working directory of whichever repo you want to work in. From there you can run the specs and cucumber features, and make patches.</p>

<p>NOTE: You do not need to use rspec-dev to work on a specific <a href="../../../../../../../classes/RSpec.html"><code>RSpec</code></a> repo. You can treat each <a href="../../../../../../../classes/RSpec.html"><code>RSpec</code></a> repo as an independent project.</p>

<p>For information about contributing to <a href="../../../../../../../classes/RSpec.html"><code>RSpec</code></a>, please refer to the following markdown files: * <a href="BUILD_DETAIL.md">Build details</a> * <a href="CODE_OF_CONDUCT.md">Code of Conduct</a> * <a href="CONTRIBUTING.md">Detailed contributing guide</a> * <a href="DEVELOPMENT.md">Development setup guide</a></p>

<h2 id="label-Test+Doubles">Test Doubles</h2>

<p>A test double is an object that stands in for another object in your system during a code example. Use the <code>double</code> method, passing in an optional identifier, to create one:</p>

<pre><code>book = double(&quot;book&quot;)
</code></pre>

<p>Most of the time you will want some confidence that your doubles resemble an existing object in your system. Verifying doubles are provided for this purpose. If the existing object is available, they will prevent you from adding stubs and expectations for methods that do not exist or that have an invalid number of parameters.</p>

<pre><code>book = instance_double(&quot;Book&quot;, :pages =&gt; 250)
</code></pre>

<p>Verifying doubles have some clever tricks to enable you to both test in isolation without your dependencies loaded while still being able to validate them against real objects. More detail is available in <a href="https://github.com/rspec/rspec-mocks/blob/master/features/verifying_doubles">their documentation</a>.</p>

<p>Verifying doubles can also accept custom identifiers, just like double(), e.g.:</p>

<pre><code>books = []
books &lt;&lt; instance_double(&quot;Book&quot;, :rspec_book, :pages =&gt; 250)
books &lt;&lt; instance_double(&quot;Book&quot;, &quot;(Untitled)&quot;, :pages =&gt; 5000)

puts books.inspect # with names, it&#39;s clearer which were actually added
</code></pre>

<h2 id="label-Method+Stubs">Method Stubs</h2>

<p>A method stub is an implementation that returns a pre-determined value. Method stubs can be declared on test doubles or real objects using the same syntax. rspec-mocks supports 3 forms for declaring method stubs:</p>

<pre><code>allow(book).to receive(:title) { &quot;The RSpec Book&quot; }
allow(book).to receive(:title).and_return(&quot;The RSpec Book&quot;)
allow(book).to receive_messages(
    :title =&gt; &quot;The RSpec Book&quot;,
    :subtitle =&gt; &quot;Behaviour-Driven Development with RSpec, Cucumber, and Friends&quot;)
</code></pre>

<p>You can also use this shortcut, which creates a test double and declares a method stub in one statement:</p>

<pre><code>book = double(&quot;book&quot;, :title =&gt; &quot;The RSpec Book&quot;)
</code></pre>

<p>The first argument is a name, which is used for documentation and appears in failure messages. If you don&#39;t care about the name, you can leave it out, making the combined instantiation/stub declaration very terse:</p>

<pre><code>double(:foo =&gt; &#39;bar&#39;)
</code></pre>

<p>This is particularly nice when providing a list of test doubles to a method that iterates through them:</p>

<pre><code>order.calculate_total_price(double(:price =&gt; 1.99), double(:price =&gt; 2.99))
</code></pre>

<h3 id="label-Stubbing+a+chain+of+methods">Stubbing a chain of methods</h3>

<p>You can use <code>receive_message_chain</code> in place of <code>receive</code> to stub a chain of messages:</p>

<pre><code>allow(double).to receive_message_chain(&quot;foo.bar&quot;) { :baz }
allow(double).to receive_message_chain(:foo, :bar =&gt; :baz)
allow(double).to receive_message_chain(:foo, :bar) { :baz }

# Given any of the above forms:
double.foo.bar # =&gt; :baz
</code></pre>

<p>Chains can be arbitrarily long, which makes it quite painless to violate the Law of Demeter in violent ways, so you should consider any use of <code>receive_message_chain</code> a code smell. Even though not all code smells indicate real problems (think fluent interfaces), <code>receive_message_chain</code> still results in brittle examples. For example, if you write <code>allow(foo).to receive_message_chain(:bar, :baz =&gt; 37)</code> in a spec and then the implementation calls <code>foo.baz.bar</code>, the stub will not work.</p>

<h2 id="label-Consecutive+return+values">Consecutive return values</h2>

<p>When a stub might be invoked more than once, you can provide additional arguments to <code>and_return</code>. The invocations cycle through the list. The last value is returned for any subsequent invocations:</p>

<pre><code>allow(die).to receive(:roll).and_return(1, 2, 3)
die.roll # =&gt; 1
die.roll # =&gt; 2
die.roll # =&gt; 3
die.roll # =&gt; 3
die.roll # =&gt; 3
</code></pre>

<p>To return an array in a single invocation, declare an array:</p>

<pre><code>allow(team).to receive(:players).and_return([double(:name =&gt; &quot;David&quot;)])
</code></pre>

<h2 id="label-Message+Expectations">Message Expectations</h2>

<p>A message expectation is an expectation that the test double will receive a message some time before the example ends. If the message is received, the expectation is satisfied. If not, the example fails.</p>

<pre><code>validator = double(&quot;validator&quot;)
expect(validator).to receive(:validate) { &quot;02134&quot; }
zipcode = Zipcode.new(&quot;02134&quot;, validator)
zipcode.valid?
</code></pre>

<h2 id="label-Test+Spies">Test Spies</h2>

<p>Verifies the given object received the expected message during the course of the test. For a message to be verified, the given object must be setup to spy on it, either by having it explicitly stubbed or by being a null object double (e.g. <code>double(...).as_null_object</code>). Convenience methods are provided to easily create null object doubles for this purpose:</p>

<pre><code>spy(&quot;invitation&quot;) # =&gt; same as `double(&quot;invitation&quot;).as_null_object`
instance_spy(&quot;Invitation&quot;) # =&gt; same as `instance_double(&quot;Invitation&quot;).as_null_object`
class_spy(&quot;Invitation&quot;) # =&gt; same as `class_double(&quot;Invitation&quot;).as_null_object`
object_spy(&quot;Invitation&quot;) # =&gt; same as `object_double(&quot;Invitation&quot;).as_null_object`
</code></pre>

<p>Verifying messages received in this way implements the Test Spy pattern.</p>

<pre><code>invitation = spy(&#39;invitation&#39;)

user.accept_invitation(invitation)

expect(invitation).to have_received(:accept)

# You can also use other common message expectations. For example:
expect(invitation).to have_received(:accept).with(mailer)
expect(invitation).to have_received(:accept).twice
expect(invitation).to_not have_received(:accept).with(mailer)

# One can specify a return value on the spy the same way one would a double.
invitation = spy(&#39;invitation&#39;, :accept =&gt; true)
expect(invitation).to have_received(:accept).with(mailer)
expect(invitation.accept).to eq(true)
</code></pre>

<p>Note that <code>have_received(...).with(...)</code> is unable to work properly when passed arguments are mutated after the spy records the received message. For example, this does not work properly:</p>

<pre><code>greeter = spy(&quot;greeter&quot;)

message = &quot;Hello&quot;
greeter.greet_with(message)
message &lt;&lt; &quot;, World&quot;

expect(greeter).to have_received(:greet_with).with(&quot;Hello&quot;)
</code></pre>

<h2 id="label-Nomenclature">Nomenclature</h2>

<h3 id="label-Mock+Objects+and+Test+Stubs">Mock Objects and Test Stubs</h3>

<p>The names Mock <a href="../../../../../../../classes/Object.html"><code>Object</code></a> and Test Stub suggest specialized Test Doubles. i.e. a Test Stub is a Test Double that only supports method stubs, and a Mock <a href="../../../../../../../classes/Object.html"><code>Object</code></a> is a Test Double that supports message expectations and method stubs.</p>

<p>There is a lot of overlapping nomenclature here, and there are many variations of these patterns (fakes, spies, etc). Keep in mind that most of the time we&#39;re talking about method-level concepts that are variations of method stubs and message expectations, and we&#39;re applying to them to <em>one</em> generic kind of object: a Test Double.</p>

<h3 id="label-Test-Specific+Extension">Test-Specific Extension</h3>

<p>a.k.a. Partial Double, a Test-Specific Extension is an extension of a real object in a system that is instrumented with test-double like behaviour in the context of a test. This technique is very common in Ruby because we often see class objects acting as global namespaces for methods. For example, in Rails:</p>

<pre><code>person = double(&quot;person&quot;)
allow(Person).to receive(:find) { person }
</code></pre>

<p>In this case we&#39;re instrumenting Person to return the person object we&#39;ve defined whenever it receives the <code>find</code> message. We can also set a message expectation so that the example fails if <code>find</code> is not called:</p>

<pre><code>person = double(&quot;person&quot;)
expect(Person).to receive(:find) { person }
</code></pre>

<p><a href="../../../../../../../classes/RSpec.html"><code>RSpec</code></a> replaces the method we&#39;re stubbing or mocking with its own test-double-like method. At the end of the example, <a href="../../../../../../../classes/RSpec.html"><code>RSpec</code></a> verifies any message expectations, and then restores the original methods.</p>

<h2 id="label-Expecting+Arguments">Expecting Arguments</h2>

<pre><code>expect(double).to receive(:msg).with(*args)
expect(double).to_not receive(:msg).with(*args)
</code></pre>

<p>You can set multiple expectations for the same message if you need to:</p>

<pre><code>expect(double).to receive(:msg).with(&quot;A&quot;, 1, 3)
expect(double).to receive(:msg).with(&quot;B&quot;, 2, 4)
</code></pre>

<h2 id="label-Argument+Matchers">Argument Matchers</h2>

<p>Arguments that are passed to <code>with</code> are compared with actual arguments received using ===. In cases in which you want to specify things about the arguments rather than the arguments themselves, you can use any of the matchers that ship with rspec-expectations. They don&#39;t all make syntactic sense (they were primarily designed for use with <a href="../../../../../../../classes/RSpec/Expectations.html"><code>RSpec::Expectations</code></a>), but you are free to create your own custom <a href="../../../../../../../classes/RSpec/Matchers.html"><code>RSpec::Matchers</code></a>.</p>

<p>rspec-mocks also adds some keyword Symbols that you can use to specify certain kinds of arguments:</p>

<pre><code>expect(double).to receive(:msg).with(no_args)
expect(double).to receive(:msg).with(any_args)
expect(double).to receive(:msg).with(1, any_args) # any args acts like an arg splat and can go anywhere
expect(double).to receive(:msg).with(1, kind_of(Numeric), &quot;b&quot;) #2nd argument can be any kind of Numeric
expect(double).to receive(:msg).with(1, boolean(), &quot;b&quot;) #2nd argument can be true or false
expect(double).to receive(:msg).with(1, /abc/, &quot;b&quot;) #2nd argument can be any String matching the submitted Regexp
expect(double).to receive(:msg).with(1, anything(), &quot;b&quot;) #2nd argument can be anything at all
expect(double).to receive(:msg).with(1, duck_type(:abs, :div), &quot;b&quot;) #2nd argument can be object that responds to #abs and #div
expect(double).to receive(:msg).with(hash_including(:a =&gt; 5)) # first arg is a hash with a: 5 as one of the key-values
expect(double).to receive(:msg).with(array_including(5)) # first arg is an array with 5 as one of the key-values
expect(double).to receive(:msg).with(hash_excluding(:a =&gt; 5)) # first arg is a hash without a: 5 as one of the key-values
</code></pre>

<h2 id="label-Receive+Counts">Receive Counts</h2>

<pre><code>expect(double).to receive(:msg).once
expect(double).to receive(:msg).twice
expect(double).to receive(:msg).exactly(n).times
expect(double).to receive(:msg).at_least(:once)
expect(double).to receive(:msg).at_least(:twice)
expect(double).to receive(:msg).at_least(n).times
expect(double).to receive(:msg).at_most(:once)
expect(double).to receive(:msg).at_most(:twice)
expect(double).to receive(:msg).at_most(n).times
</code></pre>

<h2 id="label-Ordering">Ordering</h2>

<pre><code>expect(double).to receive(:msg).ordered
expect(double).to receive(:other_msg).ordered
  # This will fail if the messages are received out of order
</code></pre>

<p>This can include the same message with different arguments:</p>

<pre><code>expect(double).to receive(:msg).with(&quot;A&quot;, 1, 3).ordered
expect(double).to receive(:msg).with(&quot;B&quot;, 2, 4).ordered
</code></pre>

<h2 id="label-Setting+Responses">Setting Responses</h2>

<p>Whether you are setting a message expectation or a method stub, you can tell the object precisely how to respond. The most generic way is to pass a block to <code>receive</code>:</p>

<pre><code>expect(double).to receive(:msg) { value }
</code></pre>

<p>When the double receives the <code>msg</code> message, it evaluates the block and returns the result.</p>

<pre><code>expect(double).to receive(:msg).and_return(value)
expect(double).to receive(:msg).exactly(3).times.and_return(value1, value2, value3)
  # returns value1 the first time, value2 the second, etc
expect(double).to receive(:msg).and_raise(error)
  # error can be an instantiated object or a class
  # if it is a class, it must be instantiable with no args
expect(double).to receive(:msg).and_throw(:msg)
expect(double).to receive(:msg).and_yield(values, to, yield)
expect(double).to receive(:msg).and_yield(values, to, yield).and_yield(some, other, values, this, time)
  # for methods that yield to a block multiple times
</code></pre>

<p>Any of these responses can be applied to a stub as well</p>

<pre><code>allow(double).to receive(:msg).and_return(value)
allow(double).to receive(:msg).and_return(value1, value2, value3)
allow(double).to receive(:msg).and_raise(error)
allow(double).to receive(:msg).and_throw(:msg)
allow(double).to receive(:msg).and_yield(values, to, yield)
allow(double).to receive(:msg).and_yield(values, to, yield).and_yield(some, other, values, this, time)
</code></pre>

<h2 id="label-Arbitrary+Handling">Arbitrary Handling</h2>

<p>Once in a while you&#39;ll find that the available expectations don&#39;t solve the particular problem you are trying to solve. Imagine that you expect the message to come with an <a href="../../../../../../../classes/Array.html"><code>Array</code></a> argument that has a specific length, but you don&#39;t care what is in it. You could do this:</p>

<pre><code>expect(double).to receive(:msg) do |arg|
  expect(arg.size).to eq 7
end
</code></pre>

<p>If the method being stubbed itself takes a block, and you need to yield to it in some special way, you can use this:</p>

<pre><code>expect(double).to receive(:msg) do |&amp;arg|
  begin
    arg.call
  ensure
    # cleanup
  end
end
</code></pre>

<h2 id="label-Delegating+to+the+Original+Implementation">Delegating to the Original Implementation</h2>

<p>When working with a partial mock object, you may occasionally want to set a message expectation without interfering with how the object responds to the message. You can use <code>and_call_original</code> to achieve this:</p>

<pre><code>expect(Person).to receive(:find).and_call_original
Person.find # =&gt; executes the original find method and returns the result
</code></pre>

<h2 id="label-Combining+Expectation+Details">Combining Expectation Details</h2>

<p>Combining the message name with specific arguments, receive counts and responses you can get quite a bit of detail in your expectations:</p>

<pre><code>expect(double).to receive(:&lt;&lt;).with(&quot;illegal value&quot;).once.and_raise(ArgumentError)
</code></pre>

<p>While this is a good thing when you really need it, you probably don&#39;t really need it! Take care to specify only the things that matter to the behavior of your code.</p>

<h2 id="label-Stubbing+and+Hiding+Constants">Stubbing and Hiding Constants</h2>

<p>See the <a href="https://github.com/rspec/rspec-mocks/blob/master/features/mutating_constants/README.md">mutating constants README</a> for info on this feature.</p>

<h2 id="label-Use+before-28-3Aexample-29-2C+not+before-28-3Acontext-29">Use <code>before(:example)</code>, not <code>before(:context)</code></h2>

<p>Stubs in <code>before(:context)</code> are not supported. The reason is that all stubs and mocks get cleared out after each example, so any stub that is set in <code>before(:context)</code> would work in the first example that happens to run in that group, but not for any others.</p>

<p>Instead of <code>before(:context)</code>, use <code>before(:example)</code>.</p>

<h2 id="label-Settings+mocks+or+stubs+on+any+instance+of+a+class">Settings mocks or stubs on any instance of a class</h2>

<p>rspec-mocks provides two methods, <code>allow_any_instance_of</code> and <code>expect_any_instance_of</code>, that will allow you to stub or mock any instance of a class. They are used in place of <code>allow</code> or <code>expect</code>:</p>

<pre><code>allow_any_instance_of(Widget).to receive(:name).and_return(&quot;Wibble&quot;)
expect_any_instance_of(Widget).to receive(:name).and_return(&quot;Wobble&quot;)
</code></pre>

<p>These methods add the appropriate stub or expectation to all instances of <code>Widget</code>.</p>

<p>This feature is sometimes useful when working with legacy code, though in general we discourage its use for a number of reasons:</p>
<ul><li>
<p>The <code>rspec-mocks</code> API is designed for individual object instances, but this  feature operates on entire classes of objects. As a result there are some  semantically confusing edge cases. For example in  <code>expect_any_instance_of(Widget).to receive(:name).twice</code> it isn&#39;t clear  whether each specific instance is expected to receive <code>name</code> twice, or if two  receives total are expected. (It&#39;s the former.)</p>
</li><li>
<p>Using this feature is often a design smell. It may be  that your test is trying to do too much or that the object under test is too  complex.</p>
</li><li>
<p>It is the most complicated feature of <code>rspec-mocks</code>, and has historically  received the most bug reports. (None of the core team actively use it,  which doesn&#39;t help.)</p>
</li></ul>

<h2 id="label-Further+Reading">Further Reading</h2>

<p>There are many different viewpoints about the meaning of mocks and stubs. If you are interested in learning more, here is some recommended reading:</p>
<ul><li>
<p>Mock Objects: <a href="http://www.mockobjects.com">www.mockobjects.com</a>/</p>
</li><li>
<p>Endo-Testing: <a href="http://www.ccs.neu.edu/research/demeter/related-work/extreme-programming/MockObjectsFinal.PDF">www.ccs.neu.edu/research/demeter/related-work/extreme-programming/MockObjectsFinal.PDF</a></p>
</li><li>
<p>Mock Roles, Not Objects: <a href="http://www.jmock.org/oopsla2004.pdf">www.jmock.org/oopsla2004.pdf</a></p>
</li><li>
<p>Test Double: <a href="http://www.martinfowler.com/bliki/TestDouble.html">www.martinfowler.com/bliki/TestDouble.html</a></p>
</li><li>
<p>Test Double Patterns: <a href="http://xunitpatterns.com/Test%20Double%20Patterns.html">xunitpatterns.com/Test%20Double%20Patterns.html</a></p>
</li><li>
<p>Mocks aren&#39;t stubs: <a href="http://www.martinfowler.com/articles/mocksArentStubs.html">www.martinfowler.com/articles/mocksArentStubs.html</a></p>
</li></ul>

<h2 id="label-Also+see">Also see</h2>
<ul><li>
<p><a href="https://github.com/rspec/rspec">github.com/rspec/rspec</a></p>
</li><li>
<p><a href="https://github.com/rspec/rspec-core">github.com/rspec/rspec-core</a></p>
</li><li>
<p><a href="https://github.com/rspec/rspec-expectations">github.com/rspec/rspec-expectations</a></p>
</li><li>
<p><a href="https://github.com/rspec/rspec-rails">github.com/rspec/rspec-rails</a></p>
</li></ul>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
    
    
    
  
</div>

    </div>
  </body>
</html>
